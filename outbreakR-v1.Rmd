---
title: "outbreakR : Insect outbreak reconstructions in R"
author: Todd Ellis (toddellis.wa AT gmail.com)
date: Oct. 2016
output:
  html_document:
    toc: true
    theme: united
---

Please feel free to e-mail me any comments, suggestions, or bug-fixes. Thanks for downloading! :)

If you're coming from RPubs or elsewhere and need the example datasets, visit either https://bitbucket.org/toddellis/outbreakr or https://github.com/toddellis/outbreakR.

## Setup

Before running any of this, don't forget to customize the working directory!

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE)
rm( list = ls()) # reset environment
# install.packages( 'pacman') # enable loading multiple required packages
library( pacman)
p_load( data.table, dplR, ggplot2) # data.table for shift function; dplR for treeMean; ggplot2 for end samples
setwd( "E:/outbreakR") # setwd to project folder, in my case 'E:/outbreakR'
```

Note: These functions make use of both `dplR` and `data.table` packages. The `ggplot2` package is used in the concluding example section.

## Corrected Indices

The `corIndex()` function below uses input host site ring-width indices and a nonhost chronology to remove the climatic noise (shared between host and non-host indices) from the host sites. This outputs 'corrected' indices, or CIs, where positive values represent positive growth from non-climatic influences, and negative values represent limited growth from, we assume, biological means. In the sample cases, we assume negative growth impacts are caused by regionally-endemic insect outbreaks like the western spruce budworm.

To describe the inputs (`corIndex <- function( rwi, crn, scale = TRUE)`): 

1. `rwi` should be your host ring-width indices (i.e., multiple trees over multiple columns). See the `dplR` package for help producing these.
2. `crn` should be a single non-host site / region chronology. See the `dplR` package for help producing these. 
3. `scale` is an optional feature which will normalize the resultant corrected indices if set to `TRUE`. This is on by default.

Note: Before using the `corIndex()` function, you should use the `treeMean()` function from the `dplR` package to combine multiple cores by tree (e.g., XXX01A, XXX01B, and XXX01C will be averaged into XXX01). See the example provided at the bottom of this document.

```{r corIndex}
corIndex <- function( rwi, crn, scale = TRUE) {
  
  ## ensure inputs are same size
  if (nrow( rwi) != nrow( crn)) {
    stop( "host rwi and nonhost crn need to be same size")
  }
  
  ## create matrices
  rwi2 <- as.matrix( rwi)
  crn2 <- matrix( NA_real_, nrow = nrow( rwi2), ncol = ncol( rwi2))
  
  ## fill crn2 with common period control chronology
  for( i in 1:dim( crn2)[1]) {
    for( j in 1:dim( crn2)[2]) {
      if( is.na( rwi2[i, j]) == TRUE) {
        crn2[i, j] <- NA
      } else {
        crn2[i, j] <- crn[i, ]
      }
    }
  }
  
  ## generate empty matrix to fill with CIs
  res <- matrix( NA_real_, nrow = nrow( rwi2), ncol = ncol( rwi2))
  
  ## fill res with unscaled CIs
  for( i  in 1:dim( res)[1]) {
    for( j in 1:dim( res)[2]) {
      res[i, j] <- rwi2[i, j] - (sd( rwi2[, j], na.rm = TRUE) / sd( crn2[, j], na.rm = TRUE)) * (crn2[i, j] - mean(crn2[, j], na.rm = TRUE))
      }
    }

  ## normalize CIs if desired
  if( scale == TRUE) {
    res2 <- matrix( NA_real_, nrow = nrow( res), ncol = ncol( res))
    for( i in 1:dim( res2)[1]) {
      for( j in 1:dim( res2)[2]) {
        res2[i, j] <- (res[i, j] - mean( res[, j], na.rm = TRUE)) / sd( res[, j], na.rm = TRUE)
      }
    }
    res <- res2
  } else {
    res
  }
  
  ## return dataframe
  res[is.nan( res)] <- NA_real_
  res <- as.data.frame( res, row.names = rownames( rwi2))
  names( res) <- colnames( rwi2)
  class( res) <- ( "data.frame")
  res
  
}

```

## Outbreak Records

The `outbreak()` function takes corrected indices -- the output of the above `corIndex()` function -- and determines years of insect outbreaks based on user-defined critea.

To describe the function's options (`outbreak <- function( ci, min = 4, sd = -1.28, perc = TRUE`): 

1. `ci` represents the corrected indices produced by `corIndex()` 
2. `min` denotes the minimum number of consecutive years that must be impacted by low growth. It must be between 4 and 8 years, and is by default set to 4. This should be customized to most closely match historical outbreak records.
3. `sd` denotes the standard deviation at least one year of growth falls under within each outbreak period. This is set to -1.28 as an (arbitrary) standard, but may be customized to better match historical records.
4. `perc` is an optional setting to produce a new column to the outbreak records, which reports the percentage of trees reporting outbreak conditions by year. This is set to `TRUE` as a default.

```{r outbreakR}

outbreak <- function( ci, min = 4, sd = -1.28, perc = TRUE) {
  
  ## Create empty data frames to fill
  res <- matrix( NA_real_, nrow = nrow( ci), ncol = ncol( ci))
  res2 <- res; res3 <- res
  ci2 <- ci
  
  ## create -1 leading and +1 lagging dataframes
  require( data.table) ## shift() function requires 'data.table' package
  lag <- as.data.frame( shift( ci, 1, fill = NA, type  = "lag", give.names = TRUE), 
                        row.names = row.names( ci)); names( lag) <- colnames( ci) 
  lead <- as.data.frame( shift( ci, 1, fill = NA, type = "lead", give.names = TRUE), 
                         row.names = row.names( ci)); colnames( lead) <- colnames( ci)

  ## create 2-year consecutive outbreak record
  for( i in 1:dim( ci2)[1]) {
    for( j in 1:dim( ci2)[2]) {
      if( is.na( ci2[i,j])) {
        ci2[i,j] <- 0
        res[i,j] <- 0
        res2[i,j] <- 0
      }
      if( is.na( lag[i,j])) {
        lag[i,j] <- 0
      }
      if( is.na( lead[i,j])) {
        lead[i,j] <- 0
      }
      if( ci2[i,j] < 0 || lag[i,j] < 0) {
        res[i,j] <- 1
      } else {
        res[i,j] <- 0
      }
      if( ci2[i,j] < 0 || lead[i,j] < 0) {
        res2[i,j] <- 1
      } else {
        res2[i,j] <- 0
      }
      res3 <- res * res2
      res <- res3
      res <- as.data.frame( res, row.names = rownames( ci2))
      names( res) <- colnames( ci2)
    }
  }
  
  ## REMNANT CODE:
  ## 'count = TRUE' was former default input in function
  ## Can be added back into function to return length of each outbreak period
  #if( count == TRUE) { 
  #  res[] <- lapply(res, function( x) sequence( rle( x)$lengths) * x)
  #  res
  #} else {
  #  res
  #}
  
  ## Get outbreak record based on minimum outbreak length
  if( !is.na(min) && (min < 4 || min > 8)) {
    stop(" min must be >= 4 years and <= 8 years")
  } 
  
  ## No duration set
  if( is.na(min)) {
    res 
  } else if( min >= 4 && min <= 8) {
    ## print("setting minimum outbreak duration ignores count = TRUE") ## remnant from 'count = TRUE' being default setting
    res[] <- lapply(res, function( x) sequence( rle( x)$lengths) * x) ## creates running count
    leads <- function(x) { ## creates function to look ahead multiple years
      as.data.frame( shift( res, n = x, fill = 0, type = "lead", 
                            give.names = TRUE), row.names = row.names( res)) >= min 
    }
    
    ## if minimum outbreak duration is 4 years -- DEFAULT
    if( min == 4) {
      leads1 <- leads(1); leads2 <- leads(2); leads3 <- leads(3)
      for( i in 1:dim( res)[1]) {
        for( j in 1:dim( res)[2]) {
          if( res[i,j] > min - 1 || leads1[i,j] || leads2[i,j] || leads3[i,j]) {
            res[i,j] <- 1
          } else { res[i,j] <- 0 }
        }
      }
    }
  
    ## if minimum outbreak duration is 5 years
    if( min == 5) {
      leads1 <- leads(1); leads2 <- leads(2); leads3 <- leads(3); leads4 <- leads(4)
      for( i in 1:dim( res)[1]) {
        for( j in 1:dim( res)[2]) 
          if( res[i,j] > min - 1 || leads1[i,j] || leads2[i,j] || leads3[i,j] || leads4[i,j]) {
            res[i,j] <- 1
          } else { res[i,j] <- 0 }
      }
    }
  
    ## if minimum outbreak duration is 6 years
    if( min == 6) {
      leads1 <- leads(1); leads2 <- leads(2); leads3 <- leads(3); leads4 <- leads(4); leads5 <- leads(5)
      for( i in 1:dim( res)[1]) {
        for( j in 1:dim( res)[2]) 
          if( res[i,j] > min - 1 || leads1[i,j] || leads2[i,j] || leads3[i,j] || leads4[i,j] || leads5[i,j]) {
            res[i,j] <- 1
          } else { res[i,j] <- 0 }
      }
    }
  
    ## if minimum outbreak duration is 7 years
    if( min == 7) {
      leads1 <- leads(1); leads2 <- leads(2); leads3 <- leads(3); leads4 <- leads(4); leads5 <- leads(5); leads6 <- leads(6)
      for( i in 1:dim( res)[1]) {
        for( j in 1:dim( res)[2]) 
          if( res[i,j] > min - 1 || leads1[i,j] || leads2[i,j] || leads3[i,j] || leads4[i,j] || leads5[i,j] || leads6[i,j]) {
            res[i,j] <- 1
          } else { res[i,j] <- 0 }
      }
    }
  
    ## if minimum outbreak duration is 8 years
    if( min == 8) {
      leads1 <- leads(1); leads2 <- leads(2); leads3 <- leads(3); leads4 <- leads(4); leads5 <- leads(5); leads6 <- leads(6); leads7 <- leads(7)
      for( i in 1:dim( res)[1]) {
        for( j in 1:dim( res)[2]) 
          if( res[i,j] > min - 1 || leads1[i,j] || leads2[i,j] || leads3[i,j] || leads4[i,j] || leads5[i,j] || leads6[i,j] || leads7[i,j]) {
            res[i,j] <- 1
          } else { res[i,j] <- 0 }
      }
    }
  }
  
## Determine outbreaks using set standard deviation
  if( !is.na(sd)) {
    res.split <- lapply( res, function(x) cumsum( c( 0, abs( diff( x)))))
    res.keep <- Map(
      ave, ci2, res.split, MoreArgs = list( FUN = function( x) !!any( x < sd))
    )
    
    res <- res * res.keep
    
  } else { res }
  
 ## Determine perecnt of site trees with outbreak conditions by year
 if( perc == TRUE) {
    res$perc <- round( rowSums( res) / rowSums( !is.na( ci)) * 100, 1)
  } else { res }
  
  res
}

```

## Example Data

I've provided four sample host sites and a nonhost chronology (in a single exmaple folder) in order to test out these functions. The example below uses one site -- *MPD* -- to create corrected indices and a site outbreak record. Please note that the `treeMean()` function from the `dplR` package is used prior to using `corIndex()`. Finally, an example outbreak record is plotted using `ggplot2` tools to show how easy and effective these two functions are with generating insect outbreak records.

```{r examples}
## load host RWIs, either:
## MPD -- 'Mount Phoebe Douglas-fir'
## SMD -- 'Sneed Mountain Douglas-fir'
## TMD -- 'Tunk Mountain Douglas-fir'
## VLD -- 'Virginia-Lily Douglas-fir'
MPD.rwi <- read.csv( "ex_input/host/MPD.rwi", header = T, sep = ";", row.names = 1)
MPD.rwi <- treeMean( MPD.rwi, autoread.ids( MPD.rwi), na.rm = T) ## treeMean() function requires 'dplR' package
tail(MPD.rwi)

## load non-host chronology
## N.B. OHP_PC1 <- 'Okanogan Highlands Ponderosa' principal component 1
PIPO.crn <- read.csv( "ex_input/nonhost/OHP_PC1.csv", header = T, row.names = 1)
tail(PIPO.crn)

## create sample CIs
MPD.ci <- corIndex( rwi = MPD.rwi, crn = PIPO.crn, scale = TRUE)
tail(MPD.ci)

## create sample outbreak record
MPD.ob <- outbreak( ci = MPD.ci, min = 4, sd = -1.28, perc = TRUE)
tail(MPD.ob)

## sample outbreak record plotting
obYears <- as.numeric( row.names( MPD.ob)) ## turn years into numeric to make referencing faster

ggplot( MPD.ob, aes( x = obYears, y = perc)) +
  geom_line( size = 0.25, linetype = "dashed", colour = "grey25") + ## percent outbreak line
  geom_line( aes( x = obYears, y = 40), linetype = "dotted", size = 0.3) + ## 40% threshold
  geom_line( aes( x = obYears, y = 80), linetype = "dotted", size = 0.4) + ## 80% threshold
  geom_line( aes( x = obYears, y = filter( 
    x = MPD.ob$perc, filter = rep( x = 1/8, times = 8), sides = 2)), ## creates moving average
    size = 1, colour = ifelse( MPD.ob$perc > 40, ## color moving average based on outbreak intensity
              ifelse( MPD.ob$perc > 80, "darkred", "darkorange"), "darkgreen")) + 
  scale_x_continuous( breaks = c( 1700, 1750, 1800, 1850, 1900, 1950, 2000)) + ## x axis breaks
  theme( axis.line = element_line( colour = "black"), axis.title = ## custom axis text
           element_text( size = 11, face = "bold"), title = element_text( size = 12, face = "bold")) +
  labs( x = "Year", y = "% outbreak") ## axis labels

```